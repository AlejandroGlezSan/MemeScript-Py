This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.py, requirements.txt, README.md
- Files matching these patterns are excluded: **/.venv/**, **/__pycache__/**, **/tests/**, **/docs/**, **/src/assets/phrases.json, *.log, *.svg, *.png, *.jpg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
README.md
requirements.txt
src/__init__.py
src/api_client.py
src/main.py
src/renderer.py
src/text_pool.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/__init__.py">

</file>

<file path="README.md">
# MemeScript-Py

**MemeScript-Py** es una aplicación de escritorio que genera memes automáticos combinando plantillas públicas de Imgflip con un pool local de frases.

## Características
- Interfaz gráfica con **CustomTkinter**.
- Descarga de plantillas desde la API pública de Imgflip.
- Pool local de frases en `src/assets/phrases.json`.
- Motor de render (Pillow) para componer texto con contorno y centrarlo.

## Estructura
memeScript-py/
├── README.md
├── .gitignore
├── requirements.txt
├── src/
│   ├── main.py
│   ├── api_client.py
│   ├── text_pool.py
│   ├── renderer.py
│   └── assets/
│       └── phrases.json
├── tests/
│   ├── test_api_client.py
│   └── test_text_pool.py
└── docs/
    └── design.md


## Instalación (entorno virtual recomendado)
```bash
python -m venv .venv
source .venv/bin/activate    # Linux / macOS
.venv\Scripts\activate       # Windows
pip install -r requirements.txt
```
</file>

<file path="requirements.txt">
# Dependencias principales
customtkinter==5.2.2
requests==2.31.0
Pillow==10.2.0

# Herramientas de desarrollo (opcional, para calidad de código)
# flake8==7.0.0
# black==24.2.0
</file>

<file path="src/api_client.py">
import random
from typing import Optional

import requests


IMGFLIP_MEMES_URL = "https://api.imgflip.com/get_memes"
DEFAULT_TIMEOUT = 10


def get_random_meme_url(timeout: int = DEFAULT_TIMEOUT) -> Optional[str]:







    try:
        resp = requests.get(IMGFLIP_MEMES_URL, timeout=timeout)
        resp.raise_for_status()
        data = resp.json()
        if not data.get("success"):
            return None
        memes = data.get("data", {}).get("memes", [])
        if not memes:
            return None
        chosen = random.choice(memes)
        return chosen.get("url")
    except Exception:

        return None
</file>

<file path="src/main.py">
from __future__ import annotations

import io
import logging
import threading
import traceback
import random
from typing import Optional, Tuple

import customtkinter as ctk
import requests
from PIL import Image


from api_client import get_random_meme_url
from renderer import render_meme
from text_pool import get_random_phrase


MAX_FILE_SIZE = 12 * 1024 * 1024
DOWNLOAD_TIMEOUT = 15
PREVIEW_SIZE = (900, 900)

ctk.set_appearance_mode("System")
ctk.set_default_color_theme("blue")

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("memeScript")


class MemeApp(ctk.CTk):

    def __init__(self, width: int = 1000, height: int = 700):
        super().__init__()
        self.title("MemeScript-Py (Refactorizado)")
        self.geometry(f"{width}x{height}")
        self.minsize(700, 500)

        # --- Layout frames ---
        self.frame_left = ctk.CTkFrame(master=self, width=320)
        self.frame_left.pack(side="left", fill="y", padx=12, pady=12)

        self.frame_right = ctk.CTkFrame(master=self)
        self.frame_right.pack(side="right", fill="both", expand=True, padx=12, pady=12)


        self.lbl_status = ctk.CTkLabel(master=self.frame_left, text="Estado: listo", wraplength=280, justify="left")
        self.lbl_status.pack(pady=(6, 12), padx=8)

        self.btn_test_api = ctk.CTkButton(master=self.frame_left, text="Probar conexión Imgflip", command=self._on_test_api)
        self.btn_test_api.pack(pady=(4, 8), padx=8, fill="x")

        self.btn_generate = ctk.CTkButton(master=self.frame_left, text="Generar meme", command=self._on_generate_meme)
        self.btn_generate.pack(pady=(4, 8), padx=8, fill="x")

        self.use_random_var = ctk.BooleanVar(value=True)
        self.chk_random = ctk.CTkCheckBox(master=self.frame_left, text="Usar frases aleatorias", variable=self.use_random_var)
        self.chk_random.pack(pady=(8, 8), padx=8, anchor="w")

        self.lbl_custom = ctk.CTkLabel(master=self.frame_left, text="Texto personalizado (opcional):")
        self.lbl_custom.pack(pady=(8, 4), padx=8, anchor="w")
        self.entry_custom = ctk.CTkEntry(master=self.frame_left, placeholder_text="Escribe texto para arriba|abajo")
        self.entry_custom.pack(pady=(0, 8), padx=8, fill="x")


        self.preview_frame = ctk.CTkFrame(master=self.frame_right)
        self.preview_frame.pack(fill="both", expand=True, padx=8, pady=8)

        self.canvas = ctk.CTkLabel(master=self.preview_frame, text="Aquí se mostrará la plantilla", anchor="center")
        self.canvas.pack(fill="both", expand=True, padx=8, pady=8)

        self._current_ctk_image: Optional[ctk.CTkImage] = None



    def _download_template(self) -> Tuple[Image.Image, str]:

        meme_url = get_random_meme_url()
        if not meme_url:
            raise RuntimeError("No se obtuvo URL de plantilla desde Imgflip.")

        resp = requests.get(meme_url, timeout=DOWNLOAD_TIMEOUT, stream=True)
        resp.raise_for_status()

        content_len = resp.headers.get("Content-Length")
        if content_len and int(content_len) > MAX_FILE_SIZE:
            raise RuntimeError("Imagen demasiado grande (>12MB).")

        img_bytes = resp.content
        image = Image.open(io.BytesIO(img_bytes)).convert("RGBA")
        return image, meme_url

    def _resolve_text_placement(self) -> Tuple[str, str, str]:

        top_text, bottom_text = "", ""

        # Caso 1: Aleatorio
        if self.use_random_var.get():
            phrase = get_random_phrase()
            pos = random.choice(["top", "bottom"])
            if pos == "top":
                return phrase, "", f"Generando meme (frase en {pos})."
            return "", phrase, f"Generando meme (frase en {pos})."

        # Caso 2: Personalizado
        custom_text = (self.entry_custom.get() or "").strip()
        if not custom_text:
            return "", "", "Generando plantilla vacía."

        if "|" in custom_text:
            parts = custom_text.split("|", 1)
            return parts[0].strip(), parts[1].strip(), "Generando meme (texto manual dividido)."

        # Caso 3: Personalizado simple (una sola línea)
        pos = random.choice(["top", "bottom"])
        msg = f"Generando meme (texto manual en {pos})."
        if pos == "top":
            return custom_text, "", msg
        return "", custom_text, msg

    def _update_ui_image(self, pil_image: Image.Image):
        """Redimensiona y actualiza la imagen en el hilo principal."""
        # Clonamos para no afectar el render original si se fuera a guardar (futuro)
        display_img = pil_image.copy()
        display_img.thumbnail(PREVIEW_SIZE, Image.LANCZOS)

        ctk_image = ctk.CTkImage(light_image=display_img, size=display_img.size)
        self._current_ctk_image = ctk_image
        self.canvas.configure(image=ctk_image, text="")

    # --- Callbacks de Botones ---

    def _on_test_api(self):
        self._set_status("Comprobando conexión...", info=True)
        self._set_buttons_state(False)
        threading.Thread(target=self._test_api_thread, daemon=True).start()

    def _on_generate_meme(self):
        self._set_status("Iniciando generación...", info=True)
        self._set_buttons_state(False)
        threading.Thread(target=self._generate_meme_thread, daemon=True).start()

    # --- Hilos de Trabajo ---

    def _test_api_thread(self):
        try:
            image, url = self._download_template()
            self.after(0, lambda: self._update_ui_image(image))
            self.after(0, lambda: self._set_status("Plantilla descargada OK.", success=True))
            logger.info("Test API exitoso: %s", url)
        except Exception as e:
            self._handle_error("Error prueba API", e)
        finally:
            self.after(0, lambda: self._set_buttons_state(True))

    def _generate_meme_thread(self):
        try:

            image, url = self._download_template()


            top, bottom, status_msg = self._resolve_text_placement()
            self.after(0, lambda: self._set_status(status_msg, info=True))


            rendered = render_meme(
                image,
                top_text=top,
                bottom_text=bottom,
                base_font_ratio=0.06,
                max_text_height_ratio=0.35,
                padding_ratio=0.02,
                stroke_width_ratio=0.06,
            )


            self.after(0, lambda: self._update_ui_image(rendered))
            self.after(0, lambda: self._set_status("Meme generado correctamente.", success=True))
            logger.info("Meme generado: %s", url)
        except Exception as e:
            self._handle_error("Error generando meme", e)
        finally:
            self.after(0, lambda: self._set_buttons_state(True))



    def _handle_error(self, context: str, e: Exception):
        tb = traceback.format_exc()
        logger.exception(context)
        print(tb)
        self.after(0, lambda: self._set_status(f"{context}: {str(e)}", error=True))

    def _set_buttons_state(self, enabled: bool):
        state = "normal" if enabled else "disabled"
        self.btn_test_api.configure(state=state)
        self.btn_generate.configure(state=state)
        self.entry_custom.configure(state=state)

    def _set_status(self, message: str, info: bool = False, success: bool = False, error: bool = False):
        prefix = "OK: " if success else "ERROR: " if error else "INFO: " if info else ""
        self.lbl_status.configure(text=f"Estado: {prefix}{message}")

    def run(self):
        self.mainloop()


def _print_startup_instructions():
    print("\n--- MemeScript-Py (Optimized) ---")
    print("Ejecuta desde la raíz: python -m src.main")

if __name__ == "__main__":
    _print_startup_instructions()
    app = MemeApp()
    app.run()
</file>

<file path="src/renderer.py">
from __future__ import annotations

import math
import tempfile
from pathlib import Path
from typing import Optional, Tuple, List, Final, Union, Any

from PIL import Image, ImageDraw, ImageFont



try:
    from PIL.Image import Resampling
    LANCZOS: Any = Resampling.LANCZOS
    BICUBIC: Any = Resampling.BICUBIC
except (ImportError, AttributeError):

    LANCZOS = getattr(Image, "LANCZOS", getattr(Image, "BILINEAR", 2))
    BICUBIC = getattr(Image, "BICUBIC", getattr(Image, "BILINEAR", 3))

from PIL.ImageDraw import ImageDraw as PILImageDraw


AnyFont = Union[ImageFont.FreeTypeFont, ImageFont.ImageFont]


MIN_FONT_SIZE: Final[int] = 12
MAX_IMAGE_PIXELS: Final[int] = 5000 * 5000
MAX_DIMENSION: Final[int] = 4000
DEFAULT_FONT_PATHS: Final[List[Path]] = [
    Path(__file__).parent / "assets" / "fonts" / "impact.ttf",
    Path("/usr/share/fonts/truetype/impact/impact.ttf"),
    Path("/usr/share/fonts/truetype/msttcorefonts/Impact.ttf"),
]

def _safe_load_font(font_path: Optional[str | Path], size: int) -> AnyFont:

    candidates: List[Path] = [Path(font_path)] if font_path else []
    candidates.extend(DEFAULT_FONT_PATHS)

    for p in candidates:
        if p.exists():
            try:

                return ImageFont.truetype(str(p), size=int(size))
            except (OSError, ValueError):
                continue
    try:
        return ImageFont.truetype("DejaVuSans-Bold.ttf", size=int(size))
    except Exception:
        return ImageFont.load_default()

def _reduce_image_if_needed(image: Image.Image, max_dim: int = MAX_DIMENSION) -> Image.Image:

    w, h = image.size
    scale: float = 1.0

    if w > max_dim or h > max_dim:
        scale = min(max_dim / w, max_dim / h)
    elif w * h > MAX_IMAGE_PIXELS:
        scale = math.sqrt(MAX_IMAGE_PIXELS / (w * h))

    if scale < 1.0:
        new_w = max(1, int(w * scale))
        new_h = max(1, int(h * scale))

        return image.resize((new_w, new_h), resample=LANCZOS)
    return image

def _get_text_size(draw: PILImageDraw, text: str, font: AnyFont) -> Tuple[int, int]:

    bbox = draw.textbbox((0, 0), str(text), font=font)
    return int(bbox[2] - bbox[0]), int(bbox[3] - bbox[1])

def _wrap_text_for_width(text: str, draw: PILImageDraw, font: AnyFont, max_width: int) -> List[str]:

    if not text:
        return []
    words = str(text).split()
    lines: List[str] = []
    current_line = ""
    for word in words:
        test_line = f"{current_line} {word}".strip()
        width, _ = _get_text_size(draw, test_line, font)
        if width <= max_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line)
            current_line = word
    if current_line:
        lines.append(current_line)
    return lines

def _draw_text_with_stroke(draw: PILImageDraw, pos: Tuple[int, int], text: str,
                           font: AnyFont, fill: str,
                           stroke_width: int, stroke_fill: str) -> None:
    """Dibuja texto con contorno (stroke) garantizando tipos enteros."""
    draw.text(
        (int(pos[0]), int(pos[1])),
        str(text),
        font=font,
        fill=fill,
        stroke_width=int(stroke_width),
        stroke_fill=stroke_fill
    )

def render_meme(image: Image.Image,
                top_text: str = "",
                bottom_text: str = "",
                font_path: Optional[str] = None,
                font_size: Optional[int] = None,
                base_font_ratio: float = 0.06,
                max_text_height_ratio: float = 0.35,
                min_font_size: int = MIN_FONT_SIZE,
                padding_ratio: float = 0.02,
                stroke_width_ratio: float = 0.06,
                stroke_fill: str = "black",
                text_fill: str = "white",
                max_width_ratio: float = 0.95) -> Image.Image:



    if image is None:
        raise ValueError("Imagen de entrada inválida.")

    img = image.convert("RGBA")
    img = _reduce_image_if_needed(img)
    w, h = img.size
    draw = ImageDraw.Draw(img)

    max_text_width = int(w * max_width_ratio)
    padding = int(min(w, h) * padding_ratio)
    allowed_total_h = int(h * max_text_height_ratio)


    current_size = int(font_size) if font_size else int(h * base_font_ratio)
    current_size = max(min_font_size, current_size)

    font = _safe_load_font(font_path, current_size)


    while current_size > min_font_size:
        font = _safe_load_font(font_path, current_size)
        t_lines = _wrap_text_for_width(top_text, draw, font, max_text_width - (2 * padding))
        b_lines = _wrap_text_for_width(bottom_text, draw, font, max_text_width - (2 * padding))

        total_h = 0
        for line in t_lines + b_lines:
            _, lh = _get_text_size(draw, line, font)
            total_h += int(lh * 1.1)

        if total_h <= allowed_total_h:
            break
        current_size -= 2


    final_top = _wrap_text_for_width(top_text, draw, font, max_text_width - (2 * padding))
    final_bot = _wrap_text_for_width(bottom_text, draw, font, max_text_width - (2 * padding))
    stroke_w = max(1, int(current_size * stroke_width_ratio))

    def draw_lines(lines: List[str], top_aligned: bool):
        if not lines: return
        curr_y: int
        if top_aligned:
            curr_y = padding
        else:
            block_h = sum(int(_get_text_size(draw, ln, font)[1] * 1.1) for ln in lines)
            curr_y = h - block_h - padding

        for ln in lines:
            lw, lh = _get_text_size(draw, ln, font)
            _draw_text_with_stroke(draw, ((w - lw) // 2, curr_y), ln, font, text_fill, stroke_w, stroke_fill)
            curr_y += int(lh * 1.1)

    draw_lines(final_top, True)
    draw_lines(final_bot, False)

    return img

if __name__ == "__main__":

    test_img = Image.new("RGB", (800, 600), color=(50, 50, 50))
    render_meme(test_img, "SISTEMA OPERATIVO", "CÓDIGO LIMPIO")
    print("Módulo renderer.py verificado.")
</file>

<file path="src/text_pool.py">
import json
import random
from pathlib import Path
from typing import List

PHRASES_PATH = Path(__file__).parent / "assets" / "phrases.json"


def load_phrases(path: Path = PHRASES_PATH) -> List[str]:
    if not path.exists():
        return []
    with open(path, "r", encoding="utf-8") as fh:
        data = json.load(fh)
    if isinstance(data, list):
        return [str(x) for x in data]
    return []


def get_random_phrase() -> str:
    phrases = load_phrases()
    if not phrases:
        return "Texto de ejemplo"
    return random.choice(phrases)
</file>

</files>
