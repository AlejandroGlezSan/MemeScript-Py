This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.py, requirements.txt, README.md
- Files matching these patterns are excluded: **/.venv/**, **/__pycache__/**, **/tests/**, **/docs/**, **/src/assets/phrases.json, *.log, *.svg, *.png, *.jpg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
README.md
requirements.txt
src/api_client.py
src/main.py
src/renderer.py
src/text_pool.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="README.md">
# MemeScript-Py

**MemeScript-Py** es una aplicación de escritorio que genera memes automáticos combinando plantillas públicas de Imgflip con un pool local de frases.

## Características
- Interfaz gráfica con **CustomTkinter**.
- Descarga de plantillas desde la API pública de Imgflip.
- Pool local de frases en `src/assets/phrases.json`.
- Motor de render (Pillow) para componer texto con contorno y centrarlo.

## Estructura
memeScript-py/
├── README.md
├── .gitignore
├── requirements.txt
├── src/
│   ├── main.py
│   ├── api_client.py
│   ├── text_pool.py
│   ├── renderer.py
│   └── assets/
│       └── phrases.json
├── tests/
│   ├── test_api_client.py
│   └── test_text_pool.py
└── docs/
    └── design.md


## Instalación (entorno virtual recomendado)
```bash
python -m venv .venv
source .venv/bin/activate    # Linux / macOS
.venv\Scripts\activate       # Windows
pip install -r requirements.txt
```
</file>

<file path="requirements.txt">
customtkinter
requests
pillow
</file>

<file path="src/api_client.py">
import random
from typing import Optional

import requests


IMGFLIP_MEMES_URL = "https://api.imgflip.com/get_memes"
DEFAULT_TIMEOUT = 10


def get_random_meme_url(timeout: int = DEFAULT_TIMEOUT) -> Optional[str]:







    try:
        resp = requests.get(IMGFLIP_MEMES_URL, timeout=timeout)
        resp.raise_for_status()
        data = resp.json()
        if not data.get("success"):
            return None
        memes = data.get("data", {}).get("memes", [])
        if not memes:
            return None
        chosen = random.choice(memes)
        return chosen.get("url")
    except Exception:

        return None
</file>

<file path="src/main.py">
from __future__ import annotations

import io
import logging
import threading
import traceback
import sys
import random
from typing import Optional, Tuple
from pathlib import Path

import customtkinter as ctk
import requests
from PIL import Image


ROOT = Path(__file__).resolve().parent.parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))


try:
    from src.api_client import get_random_meme_url
    from src.renderer import render_meme
    from src.text_pool import get_random_phrase
except Exception:

    from api_client import get_random_meme_url
    from renderer import render_meme
    from text_pool import get_random_phrase


ctk.set_appearance_mode("System")
ctk.set_default_color_theme("blue")


logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("memeScript")


class MemeApp(ctk.CTk):


    def __init__(self, width: int = 1000, height: int = 700):
        super().__init__()
        self.title("MemeScript-Py")
        self.geometry(f"{width}x{height}")
        self.minsize(700, 500)

        # --- Layout frames ---
        self.frame_left = ctk.CTkFrame(master=self, width=320)
        self.frame_left.pack(side="left", fill="y", padx=12, pady=12)

        self.frame_right = ctk.CTkFrame(master=self)
        self.frame_right.pack(side="right", fill="both", expand=True, padx=12, pady=12)


        self.lbl_status = ctk.CTkLabel(master=self.frame_left, text="Estado: listo", wraplength=280, justify="left")
        self.lbl_status.pack(pady=(6, 12), padx=8)

        self.btn_test_api = ctk.CTkButton(master=self.frame_left, text="Probar conexión Imgflip", command=self._on_test_api)
        self.btn_test_api.pack(pady=(4, 8), padx=8, fill="x")

        self.btn_generate = ctk.CTkButton(master=self.frame_left, text="Generar meme", command=self._on_generate_meme)
        self.btn_generate.pack(pady=(4, 8), padx=8, fill="x")


        self.use_random_var = ctk.BooleanVar(value=True)
        self.chk_random = ctk.CTkCheckBox(master=self.frame_left, text="Usar frases aleatorias", variable=self.use_random_var)
        self.chk_random.pack(pady=(8, 8), padx=8, anchor="w")

        self.lbl_custom = ctk.CTkLabel(master=self.frame_left, text="Texto personalizado (opcional):")
        self.lbl_custom.pack(pady=(8, 4), padx=8, anchor="w")
        self.entry_custom = ctk.CTkEntry(master=self.frame_left, placeholder_text="Escribe texto para arriba|abajo (separa con |)")
        self.entry_custom.pack(pady=(0, 8), padx=8, fill="x")


        self.preview_frame = ctk.CTkFrame(master=self.frame_right)
        self.preview_frame.pack(fill="both", expand=True, padx=8, pady=8)

        self.canvas = ctk.CTkLabel(master=self.preview_frame, text="Aquí se mostrará la plantilla", anchor="center")
        self.canvas.pack(fill="both", expand=True, padx=8, pady=8)


        self._current_ctk_image: Optional[ctk.CTkImage] = None


    def _on_test_api(self):

        self._set_status("Comprobando conexión a Imgflip...", info=True)
        self._set_buttons_state(False)
        thread = threading.Thread(target=self._test_api_thread, daemon=True)
        thread.start()

    def _test_api_thread(self):

        try:
            meme_url = get_random_meme_url()
            if not meme_url:
                raise RuntimeError("No se obtuvo URL de plantilla desde Imgflip.")


            resp = requests.get(meme_url, timeout=12, stream=True)
            resp.raise_for_status()


            content_length = resp.headers.get("Content-Length")
            if content_length and int(content_length) > 12 * 1024 * 1024:
                raise RuntimeError("Imagen demasiado grande (>12MB).")

            img_bytes = resp.content
            image = Image.open(io.BytesIO(img_bytes)).convert("RGBA")


            max_w, max_h = 900, 900
            image.thumbnail((max_w, max_h), Image.LANCZOS)


            ctk_image = ctk.CTkImage(light_image=image, size=image.size)
            self._current_ctk_image = ctk_image


            self.after(0, lambda: self._show_ctk_image(ctk_image))
            self.after(0, lambda: self._set_status("Plantilla descargada correctamente.", success=True))
            logger.info("Prueba API exitosa: %s", meme_url)
        except Exception as e:
            tb = traceback.format_exc()
            logger.exception("Error en prueba API")
            self.after(0, lambda: self._set_status(f"Error prueba API: {str(e)}", error=True))
            print(tb)
        finally:
            self.after(0, lambda: self._set_buttons_state(True))

    def _on_generate_meme(self):
        """Callback para generar meme: descarga plantilla, renderiza y muestra."""
        self._set_status("Generando meme...", info=True)
        self._set_buttons_state(False)
        thread = threading.Thread(target=self._generate_meme_thread, daemon=True)
        thread.start()

    def _generate_meme_thread(self):
        """Hilo que realiza la descarga de plantilla, render y actualización UI."""
        try:
            meme_url = get_random_meme_url()
            if not meme_url:
                raise RuntimeError("No se obtuvo URL de plantilla desde Imgflip.")

            # Descargar imagen en memoria con timeout y manejo de errores
            resp = requests.get(meme_url, timeout=15, stream=True)
            resp.raise_for_status()

            content_length = resp.headers.get("Content-Length")
            if content_length and int(content_length) > 12 * 1024 * 1024:
                raise RuntimeError("Imagen demasiado grande (>12MB).")

            img_bytes = resp.content
            image = Image.open(io.BytesIO(img_bytes)).convert("RGBA")


            top_text = ""
            bottom_text = ""

            if self.use_random_var.get():
                # Obtener una sola frase del pool
                phrase = get_random_phrase()
                # Elegir aleatoriamente si va arriba o abajo
                position = random.choice(["top", "bottom"])
                if position == "top":
                    top_text = phrase
                else:
                    bottom_text = phrase

                self.after(0, lambda pos=position: self._set_status(f"Generando meme (frase en {pos}).", info=True))
            else:
                # Texto personalizado: si contiene '|', respetar top|bottom
                custom = (self.entry_custom.get() or "").strip()
                if "|" in custom:
                    top_text, bottom_text = [s.strip() for s in custom.split("|", 1)]
                else:
                    # Si solo hay un texto personalizado, colocarlo en posición aleatoria
                    phrase = custom
                    if phrase:
                        position = random.choice(["top", "bottom"])
                        if position == "top":
                            top_text = phrase
                        else:
                            bottom_text = phrase
                        self.after(0, lambda pos=position: self._set_status(f"Generando meme (texto personalizado en {pos}).", info=True))
                    else:
                        # Si no hay texto personalizado, dejar ambos vacíos
                        top_text = ""
                        bottom_text = ""

            # Renderizar meme (usar parámetros compatibles con renderer actualizado)
            rendered = render_meme(
                image,
                top_text=top_text,
                bottom_text=bottom_text,
                font_size=None,  # dejar que renderer calcule según base_font_ratio
                base_font_ratio=0.06,
                max_text_height_ratio=0.35,
                padding_ratio=0.02,
                stroke_width_ratio=0.06,
            )

            # Redimensionar para vista previa si es muy grande
            max_w, max_h = 900, 900
            rendered.thumbnail((max_w, max_h), Image.LANCZOS)

            # Crear CTkImage para mostrar en la GUI (evita advertencias HighDPI)
            ctk_image = ctk.CTkImage(light_image=rendered, size=rendered.size)
            self._current_ctk_image = ctk_image

            self.after(0, lambda: self._show_ctk_image(ctk_image))
            self.after(0, lambda: self._set_status("Meme generado correctamente.", success=True))
            logger.info("Meme generado desde: %s", meme_url)
        except Exception as e:
            tb = traceback.format_exc()
            logger.exception("Error generando meme")
            self.after(0, lambda: self._set_status(f"Error generando meme: {str(e)}", error=True))
            print(tb)
        finally:
            self.after(0, lambda: self._set_buttons_state(True))

    def _show_ctk_image(self, ctk_image: ctk.CTkImage):
        """Muestra la CTkImage en el panel derecho."""
        self.canvas.configure(image=ctk_image, text="")

    def _set_buttons_state(self, enabled: bool):
        state = "normal" if enabled else "disabled"
        self.btn_test_api.configure(state=state)
        self.btn_generate.configure(state=state)
        self.entry_custom.configure(state=state)

    def _set_status(self, message: str, info: bool = False, success: bool = False, error: bool = False):

        prefix = ""
        if success:
            prefix = "OK: "
        elif error:
            prefix = "ERROR: "
        elif info:
            prefix = "INFO: "
        self.lbl_status.configure(text=f"Estado: {prefix}{message}")

    def run(self):
        self.mainloop()


def _print_startup_instructions():
    print("\nMemeScript-Py - Instrucciones rápidas de prueba")
    print("1) Asegúrate de tener un entorno virtual y dependencias instaladas:")
    print("   python -m venv .venv && source .venv/bin/activate  # o .venv\\Scripts\\activate en Windows")
    print("   pip install -r requirements.txt")
    print("2) Ejecuta desde la raíz del repo: python -m src.main  (o python src/main.py)")
    print("3) En la ventana: pulsa 'Probar conexión Imgflip' y luego 'Generar meme'.")
    print("4) Si algo falla, copia el texto del estado y pégalo como feedback.\n")


if __name__ == "__main__":
    _print_startup_instructions()
    app = MemeApp()
    app.run()
</file>

<file path="src/renderer.py">
from __future__ import annotations

import math
import textwrap
from pathlib import Path
from typing import Optional, Tuple, List

from PIL import Image, ImageDraw, ImageFont


DEFAULT_FONT_SIZE = 48
MIN_FONT_SIZE = 12
MAX_IMAGE_PIXELS = 5000 * 5000
MAX_DIMENSION = 4000
DEFAULT_FONT_PATHS: List[Path] = [
    Path(__file__).parent / "assets" / "fonts" / "impact.ttf",
    Path(__file__).parent / "assets" / "fonts" / "Impact.ttf",
    Path("/usr/share/fonts/truetype/impact/impact.ttf"),
    Path("/usr/share/fonts/truetype/msttcorefonts/Impact.ttf"),
]


def _safe_load_font(font_path: Optional[str], size: int) -> ImageFont.FreeTypeFont:




    candidates: List[Path] = []
    if font_path:
        candidates.append(Path(font_path))
    candidates.extend([p for p in DEFAULT_FONT_PATHS if p is not None])

    for p in candidates:
        try:
            if p and p.exists():
                return ImageFont.truetype(str(p), size=size)
        except Exception:
            continue


    try:
        return ImageFont.truetype("DejaVuSans-Bold.ttf", size=size)
    except Exception:

        return ImageFont.load_default()


def _reduce_image_if_needed(image: Image.Image, max_dim: int = MAX_DIMENSION) -> Image.Image:




    w, h = image.size
    if w > max_dim or h > max_dim:
        scale = min(max_dim / w, max_dim / h)
        new_w = max(1, int(w * scale))
        new_h = max(1, int(h * scale))
        return image.resize((new_w, new_h), Image.LANCZOS)

    if w * h > MAX_IMAGE_PIXELS:
        scale = math.sqrt(MAX_IMAGE_PIXELS / (w * h))
        new_w = max(1, int(w * scale))
        new_h = max(1, int(h * scale))
        return image.resize((new_w, new_h), Image.LANCZOS)
    return image


def _wrap_text_for_width(text: str, draw: ImageDraw.ImageDraw, font: ImageFont.FreeTypeFont, max_width: int) -> List[str]:




    if not text:
        return []

    text = " ".join(text.split())
    words = text.split(" ")
    lines: List[str] = []
    current = ""
    for w in words:
        test = f"{current} {w}".strip()
        bbox = draw.textbbox((0, 0), test, font=font)
        width = bbox[2] - bbox[0]
        if width <= max_width or not current:
            current = test
        else:
            lines.append(current)
            current = w
    if current:
        lines.append(current)

    # Si alguna línea aún es demasiado larga (palabra larga), usar textwrap con estimación
    final_lines: List[str] = []
    for line in lines:
        bbox = draw.textbbox((0, 0), line, font=font)
        if bbox[2] - bbox[0] <= max_width:
            final_lines.append(line)
        else:
            avg_char_w = (bbox[2] - bbox[0]) / max(1, len(line))
            if avg_char_w <= 0:
                final_lines.append(line)
            else:
                est_chars = max(1, int(max_width / avg_char_w))
                wrapped = textwrap.wrap(line, width=est_chars)
                final_lines.extend(wrapped if wrapped else [line])
    return final_lines


def _draw_text_with_stroke(draw: ImageDraw.ImageDraw, pos: Tuple[int, int], text: str, font: ImageFont.FreeTypeFont,
                           fill: str, stroke_width: int, stroke_fill: str) -> None:
    """
    Dibuja texto con contorno. Usa stroke_width/stroke_fill si la versión de Pillow lo soporta,
    si no, hace un fallback dibujando el texto desplazado en 8 direcciones.
    """
    try:
        draw.text(pos, text, font=font, fill=fill, stroke_width=stroke_width, stroke_fill=stroke_fill)
    except TypeError:
        x, y = pos
        offsets = [(-stroke_width, -stroke_width), (-stroke_width, 0), (-stroke_width, stroke_width),
                   (0, -stroke_width), (0, stroke_width),
                   (stroke_width, -stroke_width), (stroke_width, 0), (stroke_width, stroke_width)]
        for dx, dy in offsets:
            draw.text((x + dx, y + dy), text, font=font, fill=stroke_fill)
        draw.text(pos, text, font=font, fill=fill)


def render_meme(image: Image.Image,
                top_text: str = "",
                bottom_text: str = "",
                font_path: Optional[str] = None,
                font_size: Optional[int] = None,
                base_font_ratio: float = 0.06,
                max_text_height_ratio: float = 0.35,
                min_font_size: int = MIN_FONT_SIZE,
                padding_ratio: float = 0.02,
                stroke_width_ratio: float = 0.06,
                stroke_fill: str = "black",
                text_fill: str = "white",
                max_width_ratio: float = 0.95) -> Image.Image:











    if image is None:
        raise ValueError("image no puede ser None")

    img = image.convert("RGBA")
    img = _reduce_image_if_needed(img)

    w, h = img.size
    draw = ImageDraw.Draw(img)

    max_text_width = max(10, int(w * max_width_ratio))
    padding = max(4, int(min(w, h) * padding_ratio))

    if font_size and font_size > 0:
        initial_font_size = int(font_size)
    else:
        initial_font_size = max(min_font_size, int(h * base_font_ratio))

    def _measure_block_height(lines: List[str], font: ImageFont.FreeTypeFont, line_spacing: float = 1.05) -> int:
        if not lines:
            return 0
        total = 0
        for ln in lines:
            bbox = draw.textbbox((0, 0), ln, font=font)
            line_h = bbox[3] - bbox[1]
            total += int(line_h * line_spacing)
        return total

    def _truncate_line_to_width(line: str, font: ImageFont.FreeTypeFont, max_w: int) -> str:
        if not line:
            return line
        bbox = draw.textbbox((0, 0), line, font=font)
        if bbox[2] - bbox[0] <= max_w:
            return line
        ellipsis = "…"
        low, high = 0, len(line)
        best = ""
        last_bbox = bbox
        while low <= high:
            mid = (low + high) // 2
            candidate = line[:mid].rstrip() + ellipsis
            last_bbox = draw.textbbox((0, 0), candidate, font=font)
            if last_bbox[2] - last_bbox[0] <= max_w:
                best = candidate
                low = mid + 1
            else:
                high = mid - 1
        if best:
            return best
        # Fallback: approximate truncation
        avg_char_w = (last_bbox[2] - last_bbox[0]) / max(1, len(line))
        est_chars = max(1, int(max_w / avg_char_w)) if avg_char_w > 0 else max(1, len(line) // 2)
        return line[:est_chars].rstrip() + ellipsis

    def _shrink_lines_to_height(lines: List[str], font: ImageFont.FreeTypeFont, allowed_h: int, max_w: int) -> List[str]:
        if _measure_block_height(lines, font) <= allowed_h:
            return lines
        new_lines = [_truncate_line_to_width(ln, font, max_w) for ln in lines]
        # Combinar líneas hasta que quepa
        while _measure_block_height(new_lines, font) > allowed_h and len(new_lines) > 1:
            a = new_lines[-2]
            b = new_lines[-1]
            combined = (a + " " + b).strip()
            combined = _truncate_line_to_width(combined, font, max_w)
            new_lines = new_lines[:-2] + [combined]
        if _measure_block_height(new_lines, font) > allowed_h and len(new_lines) == 1:
            new_lines = [_truncate_line_to_width(new_lines[0], font, max_w)]
        return new_lines

    def _fit_font_and_lines(top: str, bottom: str, start_size: int) -> Tuple[ImageFont.FreeTypeFont, int, List[str], List[str]]:
        size = start_size
        allowed_total_h = max(10, int(h * max_text_height_ratio))
        while size >= min_font_size:
            f = _safe_load_font(font_path, size=size)
            top_lines = _wrap_text_for_width(top, draw, f, max_text_width - 2 * padding)
            bottom_lines = _wrap_text_for_width(bottom, draw, f, max_text_width - 2 * padding)
            top_h = _measure_block_height(top_lines, f)
            bottom_h = _measure_block_height(bottom_lines, f)
            total_h = top_h + bottom_h + 2 * padding
            if total_h <= allowed_total_h or size == min_font_size:
                # Truncar líneas si alguna excede ancho o altura permitida
                top_lines = _shrink_lines_to_height(top_lines, f, max(0, allowed_total_h - bottom_h - padding), max_text_width - 2 * padding)
                bottom_lines = _shrink_lines_to_height(bottom_lines, f, max(0, allowed_total_h - top_h - padding), max_text_width - 2 * padding)
                return f, size, top_lines, bottom_lines
            size = max(min_font_size, size - 2)
            if size == min_font_size:
                f = _safe_load_font(font_path, size=size)
                top_lines = _wrap_text_for_width(top, draw, f, max_text_width - 2 * padding)
                bottom_lines = _wrap_text_for_width(bottom, draw, f, max_text_width - 2 * padding)
                top_lines = _shrink_lines_to_height(top_lines, f, max(0, allowed_total_h - _measure_block_height(bottom_lines, f) - padding), max_text_width - 2 * padding)
                bottom_lines = _shrink_lines_to_height(bottom_lines, f, max(0, allowed_total_h - _measure_block_height(top_lines, f) - padding), max_text_width - 2 * padding)
                return f, size, top_lines, bottom_lines
        f = _safe_load_font(font_path, size=min_font_size)
        top_lines = _wrap_text_for_width(top, draw, f, max_text_width - 2 * padding)
        bottom_lines = _wrap_text_for_width(bottom, draw, f, max_text_width - 2 * padding)
        top_lines = _shrink_lines_to_height(top_lines, f, int(h * max_text_height_ratio / 2), max_text_width - 2 * padding)
        bottom_lines = _shrink_lines_to_height(bottom_lines, f, int(h * max_text_height_ratio / 2), max_text_width - 2 * padding)
        return f, min_font_size, top_lines, bottom_lines

    font, used_font_size, top_lines, bottom_lines = _fit_font_and_lines(top_text, bottom_text, initial_font_size)
    stroke_width = max(1, int(max(1, used_font_size * stroke_width_ratio)))

    def _block_height(lines: List[str], font: ImageFont.FreeTypeFont, line_spacing: float = 1.05) -> int:
        return _measure_block_height(lines, font, line_spacing)

    top_block_h = _block_height(top_lines, font)
    bottom_block_h = _block_height(bottom_lines, font)

    # Dibujar top lines (asegurando límites)
    y = padding
    for ln in top_lines:
        bbox = draw.textbbox((0, 0), ln, font=font)
        line_w = bbox[2] - bbox[0]
        line_h = bbox[3] - bbox[1]
        x = max(0, (w - line_w) // 2)
        if y + line_h > h - padding:
            break
        _draw_text_with_stroke(draw, (x, y), ln, font, fill=text_fill, stroke_width=stroke_width, stroke_fill=stroke_fill)
        y += int(line_h * 1.05)

    # Dibujar bottom lines (desde abajo hacia arriba), evitando solapamientos
    y_bottom_start = h - bottom_block_h - padding
    if y_bottom_start < y + padding:
        y_bottom_start = max(y + padding, padding)
    y = y_bottom_start
    for ln in bottom_lines:
        bbox = draw.textbbox((0, 0), ln, font=font)
        line_w = bbox[2] - bbox[0]
        line_h = bbox[3] - bbox[1]
        x = max(0, (w - line_w) // 2)
        if y + line_h > h - padding:
            break
        _draw_text_with_stroke(draw, (x, y), ln, font, fill=text_fill, stroke_width=stroke_width, stroke_fill=stroke_fill)
        y += int(line_h * 1.05)

    return img


# Demo rápido si se ejecuta como script
if __name__ == "__main__":
    import tempfile

    demo_img = Image.new("RGB", (800, 600), color=(60, 60, 60))
    top = "CUANDO EL CÓDIGO COMPILA"
    bottom = "Y NADIE SABE POR QUÉ"
    out = render_meme(demo_img, top, bottom, font_path=None, font_size=None, base_font_ratio=0.06, max_text_height_ratio=0.35, padding_ratio=0.02, stroke_width_ratio=0.06)
    tmp = Path(tempfile.gettempdir()) / "meme_demo_output.png"
    out.convert("RGB").save(tmp)
    print(f"Meme demo guardado en: {tmp}")
</file>

<file path="src/text_pool.py">
import json
import random
from pathlib import Path
from typing import List

PHRASES_PATH = Path(__file__).parent / "assets" / "phrases.json"


def load_phrases(path: Path = PHRASES_PATH) -> List[str]:
    if not path.exists():
        return []
    with open(path, "r", encoding="utf-8") as fh:
        data = json.load(fh)
    if isinstance(data, list):
        return [str(x) for x in data]
    return []


def get_random_phrase() -> str:
    phrases = load_phrases()
    if not phrases:
        return "Texto de ejemplo"
    return random.choice(phrases)
</file>

</files>
